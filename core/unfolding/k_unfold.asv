function M = k_unfold(varargin)
% mode_n1n2_unfold unfold a tensor into a tensor of size Ikx...IR.
%     Note that Ik = I1x..xIk,IR=I(k+1)x...xIN
%
%     TU = k_unfold(T) unfold tensor T into a matrix by arranging the first 
%     mode as row and other modes as column in little-endian order, just
%     like mode_n_unfolding().
%
%     TU = mode_n1n2_unfold(T,n) unfold tensor T into a tensor unfolded of size
%     In1xIn2x...xInnxIR in little-endian order,n is a vector. Note that IR is the
%     product of remaining dimensions,IR = ΠIi,i∈[1,T.ndims] and
%     i≠n1,...,nn
%
%     TU = mode_n1n2_unfold(T,n1,n2...nn) unfold tensor T into a tensor unfolded of size
%     In1xIn2x...xInnxIR in little-endian order. Note that IR is the
%     product of remaining dimensions,IR = ΠIi,i∈[1,T.ndims] and
%     i≠n1,...,nn
% Examples
%   
    % Input must be Tensor class
    if nargin == 0 || ~isa(varargin{1},'tensor')
        error("Input tensor must be tensor class data")
    end
    TU = varargin{1};

    if nargin == 1
        modeN = 1;
    elseif nargin == 2 
        if isnumeric(varargin{2}) && varargin{2} == int8(varargin{2}) && min(a)>0 && max(a)<=TU.ndim
            modeN = int8(varargin{2});
        else
            error("Please input correct mode vector(integer between 1 and ndim)!")
        end
    else
        % nargin >= 3
        if isnumeric(varargin{2:end}) && varargin{2:end} == int8(varargin{2:end}) && min(varargin{2:end})>0 && max(varargin{2:end})<=TU.ndim
            modeN = int8(varargin{2:end});
        else
            error("Please input correct mode vector(integer between 1 and ndim)!")
        end
    end

    % Get the last mode IR
    idx = true(TU.dim,1);
    idx(modeN) = false;
    mode_col = 1:TU.dim;
    mode_col = mode_col(idx);
    
    % Litte endian order
    TU = permute(TU,[modeN,mode_col]);
    modeList = num2cell([modeN,prob(mode_col)]);
    TU = reshape(TU,modeList{:});
   
end